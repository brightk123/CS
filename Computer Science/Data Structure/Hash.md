# Hash

해시는 입력 데이터를 고정된 길이의 데이터로 변환된 값

> 알고리즘을 통해서 값을 추출하고 활용하는 것


→ 암호, 블록체인, 메시지 인증 코드 등에서 활용됨!!

# 해시(Hash)

---

해시는 입력된 데이터를 고정된 길이의 데이터로 변환된 값

이때, key 값이 ‘해시 함수’에 의해서 변환한다!

![./img/Hash1.png](/Computer%20Science/Data%20Structure/img/Hash1.png)

## 1. 자료구조의 특징

- 키에 데이터를 매핑할 수 있는 데이터 구조
    - `HashMap<String, Integer>`는 문자열을 숫자에 매핑 (예: `"Lee" → 5`, `"Kim" → 3`)
- 해시 함수를 통해 키의 데이터를 배열에 저장할 수 있는 주소(인덱스 번호)를 계산
- 키를 통해서 저장된 데이터를 빠르게 찾고, 저장 및 탐색 속도가 빨라진다

## 2. 용어 정리

### 1) 해시 함수

> 임의의 데이터를 고정된 길이의 값으로 리턴해주는 함수
> 

```java
Integer hashFunction(String key) {	
    return (int)(key.charAt(0)) % 100;
}
```

→ 너무 복잡스…

### 2) 해시 테이블

> 키와 값을 함께 저장해 둔 데이터 구조 → 직접 접근이 가능
> 

| **index** | **key** | **value** |
| --- | --- | --- |
| 0 | 가은 | 100,000 |
| 1 | 경아 | 280,000 |
| 2 | 윤수 | 120,000 |
| 3 | 소은 | 300,000 |
| 4 | 수인 | 103,000 |

## 3. 해싱(Hashing)

해시 함수에서 해시를 출력하고 → 해시 테이블에 저장하는 과정까지

![./image.png](/Computer%20Science/Data%20Structure/img/Hash2.png)

- 버킷: 하나의 주소를 갖는 파일의 한 구역
    - 버킷의 크기 = 같은 주소에 포함될 수 있는 레코드의 수

## 4. 장단점

### 1) 장점

- 데이터 저장/ 읽기 속도(검색 속도)가 빠름
- 해시는 키에 대한 데이터가 있는지 확인하기 쉬운

### 2) 단점

- 저장공간이 많이 필요함
- 여러 키에 해당하는 주소(인덱스)가 동일하면, 충돌을 해결하기 위한 자료구조가 필요함

## 5. 주요 용도

- 검색이 많이 필요한 경우
- 저장, 삭제, 읽기가 빈번한 경우

<aside>
💡

HashMap 클래스를 주로 사용한다

</aside>

```java
HashMap<String, Integer> map = new HashMap<>();
```

# 충돌

---

### 다른 키가 있는데, 첫 문자가 같다면 인덱스는 동일하게 반환될 것임

→ 배열에서 같은 장소에 저장되고 이전에 저장된 정보는 사라짐

## 0. 충돌 발생 이유

- 함수 알고리즘의 성능이 안 좋을 때
- 저장되는 데이터 양이 해시 테이블의 크기보다 클 때

## 1. 충돌 해결하기

### 1) Chaining 기법

- 해시 테이블 저장공간 외의 공간을 활용하는 기법
- Linked List 자료 구조 이용

![image.png](/Computer%20Science/Data%20Structure/img/Hash3.png)

### 2) Linear Probing 기법

- 해시 테이블 저장공간 안에서 충돌 문제를 해결하는 기법
- 해당 해시 주소의 다음 주소부터 맨 처음까지 순회하며 빈 공간을 찾음

→ 저장공간의 활용도 높아짐