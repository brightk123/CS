# Array

## 개요

- **배열 (Array)** : 같은 타입의 데이터를 `연속적인 메모리 공간`에 저장하는 자료 구조
                         각 요소는 인덱스(index)로 접근할 수 있으며, 0번 인덱스부터 시작
    
    ** `연속적인 메모리 공간`
    → 데이터가 메모리(RAM)상에서 끊기지 않고 바로 이어지는 주소에 저장 되는 것
    
    ex) int형이 4바이트 일 경우
    
    ```java
    int arr[4] = {10, 20, 30, 40};
    ```
    
    | 인덱스 | 값 | 메모리 주소 (예시) |
    | --- | --- | --- |
    | arr[0] | 10 | 1000 |
    | arr[1] | 20 | 1004 |
    | arr[2] | 30 | 1008 |
    | arr[3] | 40 | 1012 |
    
    위 표를 보면
    다음 요소의 주소 = 이전 요소 주소 + 요소 크기
    ⇒ arr[2]에 접근하려면 **arr[0] + 2*(sizeof(int)로 계산** 가능 → `O(1) 접근`
    

## 배열의 특징

1. 고정된 크기
- 배열은 크기가 고정.
- 배열 선언 시 메모리 크기가 결정 ⇒ 추후 변경 불가
** 배열 크기 변경 시 새로운 배열을 생성하고 기존 배열을 복사
2. 빠른 검색
- 인덱스를 통해 각 요소에 빠르게 접근할 수 있음
- 원하는 데이터를 인덱스를 통해 즉시 찾기 때문에 O(1)의 시간 복잡도를 가짐 
3. 데이터 삽입 및 삭제
- 배열의 크기가 고정되어 있기 때문에 삽입하거나 삭제하려는 위치에 이미 데이터가 존재할 수 있음
⇒ 해당 요소를 삭제하거나 삽입하려면 기존의 요소들을 뒤로 이동하거나 앞으로 이동하는 것 필요
⇒ 요소 삽입 위치에 따라 최대 O(n)의 시간 복잡도를 가질 수 있음

## 배열의 시간 복잡도 (Time Complexity)

| 연산 | 시간 복잡도 | 설명 |
| --- | --- | --- |
| 접근 (Access) | O(1) | 인덱스를 통한 즉시 접근 |
| 탐색 (Search) | O(n) | 특정 값을 찾기 위해 순차 탐색 필요 |
| 삽입 (Insert) | O(n) | 해당 요소를 추가 한 뒤 나머지 요소를 뒤로 이동 |
| 삭제 (Delete) | O(n) | 해당 요소를 삭제 한 뒤 나머지 요소를 앞으로 이동 |

> 시간 복잡도(Time Complexity)
> 
> 
> ⇒ 입력 크기(n)가 커질 때 알고리즘이나 연산이 걸리는 시간의 증가량을 표현하는 방식
> 
> - O(1) 시간 복잡도
>     
>     — 상수 시간을 의미
>     
>     — 데이터 크기 n에 상관 없이 항상 일정한 시간에 동작하는 연산이라는 뜻
>     

## 배열의 장단점

### 장점

- 빠른 인덱스 접근 가능
→ 배열이 연속된 공간에 저장되기 때문에 arr[i]는 수학적으로 계산된 주소로 즉시 접근 가능 (포인터 연산 기반)

### 단점

- 크기 조절이 어려움
    
    → 배열의 크기를 늘려야 할 때, 연속된 더 큰 공간이 필요하기 때문에 다른 위치로 전체 복사 필요
    → 중간 요소 삽입/삭제시 기존 요소들을 이동해야 함
    

## 배열을 이용한 알고리즘 예시

---

## 자주 묻는 면접 질문

Q1. 배열과 ArrayList 차이점?

Q2. 배열에서 중간에 값을 삽입하거나 삭제하려면?

Q3. 배열의 장점과 단점

Q4. 다차원 배열

Q5. 배열의 크기 변경이 필요한 경우 어떤 방식으로 처리하는지?

참고

https://jyunslog.tistory.com/52

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Array.md