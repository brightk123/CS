# Trie

탐색 트리의 일종으로, 동적 집합이나 연관 배열을 저장하는 데 사용되는 트리 자료 구조

_→ 동적 집합 : 삽입, 삭제, 검색이 가능한 데이터 집합_

_→ 연관 배열 : 키 하나와 값 하나가 연관되어 있어서 키를 통해 값을 얻을 수 있는 배열_

주로 **문자열을 저장**하고 **빠르게 탐색**하기 위해 사용한다
메모리를 비교적 많이 사용하지만, 탐색 속도가 매우 빠르다 **O(L)
→** *최악의 경우 공간 복잡도는 O(N*L)\*

### 트라이의 형태

Trie에 들어있는 문자열

apple, april, bus, busy, beer, best

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fn3DKG%2FbtsjYyjBfNc%2FAAAAAAAAAAAAAAAAAAAAAIRd_1nkUDoptePSiUaseNFIq3jZP_Z6ahf-CAr6r6rP%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DJX%252Fy695sMK%252BoRM6lzLinEm2PvLU%253D)

### 트라이의 구조 (특징)

- 루트 노드

  - 루트 노드는 항상 비어있다
  - 노드의 모든 자손은 노드에 연관된 문자열의 **공통 접두사를 공유**한다

- 노드

  - 어떤 노드도 그 노드 자체와 연관된 키는 저장하지 않는다
    → 대신 노드가 트리에서 차지하는 위치가 연관된 키를 정의한다
    즉, 키의 값은 자료 구조 전체에 분산된다

- isEndOfWord 표시
  - 문자열의 마지막 문자가 되면 노드에 마지막 노드라는 표시를 한다 (파란색 부분)
    → `boolean` 활용

### 연산 과정

- **삽입**
  1. 루트에서 시작하여 삽입할 문자열의 각 문자를 따라 순서대로 자식 노드로 이동한다
  2. 만약 해당 문자에 해당하는 자식 노드가 없으면, 새로운 노드를 생성하고 연결한다
  3. 문자열의 마지막 문자에 해당하는 노드에 도달하면, `isEndOfWord` 값을 `true`로 변경한다
- **검색**

  1. 루트에서 시작하여 검색할 문자열의 각 문자를 따라 자식 노드로 이동한다
  2. 이동 중에 해당 문자의 자식 노드가 존재하지 않으면, 트라이에 그 단어가 없는 것이다
  3. 마지막 문자에 해당하는 노드까지 도달했다면, `isEndOfWord`값을 확인한다

     → `true`여야만 온전한 단어로 저장이 되어있는 것이다

- **삭제**
  1. 주어진 단어를 찾아 하위 노드로 단어의 길이만큼 내려간다
  2. 단어의 끝에 도달하면 해당 노드의 `isEndOfWord` 값을 `false`로 바꾼다
  3. 마지막 글자에서 부모 노드 방향으로 돌아오면서 삭제를 진행한다 **(Callback 형식)**
  - **삭제 조건**
    - `isEndofWord == false` 이면서 자식 노드를 가지고 있지 않을 때만 물리적으로 삭제한다

### 활용 사례

- 검색 엔진의 자동 완성 : 사용자가 “appl”까지 입력했을 때 “apple”, “application”등을 추천
- IDE의 코드 자동 완성 : `System.`을 입력했을 때 `System.out`, `System.in`등을 보여주는 기능
- 맞춤법 검사기 : 사전에 없는 단어일 경우, 비슷한 단어를 추천
- IP 라우팅 테이블 : 가장 긴 접두어 일치(Longest Prefix Match) 원칙에 따라 라우팅 경로를 찾을 때 사용

---

# Trie VS Hash Map

**공통점** : 특정 키(key)를 저장하고 이를 통해 빠르게 값을 찾아내는 것을 목표로 한다

→ 둘 다 문자열 집합을 저장하고, 특정 문자열이 집합에 포함되어 있는지 확인할 수 있음

### 상황별 비교

1. **단순 단어 검색**

   - **Hash Map**
     - 동작 : ‘apple’의 해시 값을 계산해서 단어의 존재 확인
     - 성능 : 평균 O(1)로 매우 빠름
   - **Trie**
     - 동작 : 루트부터 a, p, p, l, e 경로를 따라 이동하고 `isEndOfWord` 확인
     - 성능 : O(L)로 문자열 길이만큼 시간이 걸림

   → 단순 존재 여부만 확인할 때는 Hash Map이 일반적으로 더 빠르고 효율적이다

2. **접두어 기반 검색**

   예) ‘app’으로 시작하는 모든 단어를 추천해주세요

   - **Hash Map**
     - 동작 : 모든 키를 하나씩 다 꺼내서 ‘app’으로 시작하는지 확인
   - **Trie**
     - 동작 : a, p, p 경로로 이동한 뒤 그 아래에 연결된 모든 자식 노드들을 확인

   → 자동 완성, 접두어 검색 기능에서는 Trie가 압도적으로 유리하며, 사실상 이 기능을 위해 태어난 자료구조이다

3. **공간 효율성**

   - **Hash Map**
     - ‘apple’, ‘apply’, ‘april’ 세 단어 전체가 메모리에 각각 올라감
   - **Trie**
     - ‘ap’라는 공통된 접두어는 한 번만 저장되기 때문에 메모리가 절약된다

   → **Trie가 유리한 상황** : 영어 사전처럼 공통 접두사가 많은 경우

   → **Hash Map이 유리한 상황** : 공통 접두사가 거의 없는 무작위 문자열 집합인 경우
