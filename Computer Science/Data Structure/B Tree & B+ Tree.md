# B Tree & B+ Tree


## 개요

- **왜 B/B+트리인가?**  
  디스크/SSD는 랜덤 I/O가 비싸므로, 한 노드(페이지)에 **많은 키와 자식(=팬아웃↑)**을 담아 **트리 높이(log_f N)**를 극단적으로 낮추기 위해 고안된 **균형 다진 트리**.
- **B-tree**: 값(레코드 또는 포인터)이 **내부/리프 모두에** 있을 수 있음.  
- **B+tree**: **값은 리프에만**, 내부 노드는 **키+자식 포인터만**. 리프들이 **연결 리스트**로 이어져 있어 **범위 스캔**이 빠름.
- **실무**: “B-tree 인덱스”라고 불러도 실제 구현은 **대부분 B+tree 변형**(DB, 파일시스템 등).
- **균형 유지**: 두 트리 모두 **모든 리프의 높이가 동일**(자기 균형). 노드가 꽉 차면 **분할(split)**, 너무 비면 **재분배/병합(merge)**.
- (참고) **BST**는 이진(자식 ≤ 2)이므로 높이가 쉽게 커짐. B/B+는 **다진** 구조로 **높이를 낮춰** 대용량에 유리.

### BST
![BST](/Computer%20Science/Data%20Structure/img/BST.png)
---

### B-tree
![B-tree](/Computer%20Science/Data%20Structure/img/BTree.png)
---

### B+tree
![B+tree](/Computer%20Science/Data%20Structure/img/Bplustree.png)
---

## 시간 복잡도

> f = 평균 **팬아웃**(자식 수). 보통 매우 커서 실제 높이는 **2~4 레벨** 수준.

| 연산 | B-tree | B+tree |
|---|---|---|
| **탐색(점 조회)** | `O(log_f N)` | `O(log_f N)` *(대개 높이가 더 낮아 체감상 빠른 경향)* |
| **삽입/삭제** | `O(log_f N)` | `O(log_f N)` |
| **범위 질의** (`BETWEEN`, 정렬+LIMIT) | 보통 비효율적(리프 연결 없음) | **`O(log_f N + 결과개수)`** (리프 연결 덕분) |

---

## 특징

### B-tree
- **값 저장 위치**: 내부/리프 **둘 다 가능**(구현에 따라 내부에도 값).
- **노드 구성**: `[ (키,값) ... ] + 자식 포인터들` (키는 오름차순).
- **균형/차수**: 최대 자식 **M**, 최대 키 **M-1**; (루트 제외) 최소 자식 **⌈M/2⌉**, 최소 키 **⌈M/2⌉-1**.
- **디스크 친화성**: 페이지에 (키,값)이 함께 있어 **팬아웃이 B+보다 다소 작을 수 있음**.

#### B-tree 를 사용할 때 중요한 파라미터

| 항목 | 의미 |
| --- | --- |
| **M** | 각 노드의 **최대 자녀 노드 수** |
| **M - 1** | 각 노드의 **최대 키 수** |
| **⌈M/2⌉** | (루트 제외) 각 노드의 **최소 자녀 노드 수** |
| **⌈M/2⌉ - 1** | (루트 제외) 각 노드의 **최소 키 수** |

### B+tree
- **값 저장 위치**: **리프 전용**. 내부는 **키+자식 포인터만** → **팬아웃↑, 높이↓**.
- **리프 연결**: 리프들이 **좌→우 단방향(또는 양방향) 연결** → **범위 스캔**/정렬 질의에 최적.
- **클러스터링**: (DB 구현 따라) 리프가 실제 행을 담거나, **행 포인터/PK**를 담아 추가 조회.
- **페이지 친화**: 내부에 값이 없어 **동일 페이지에 더 많은 키** → 캐시 효율, I/O 절감.

---

## 장단점

### B-tree
- **장점**
  - 내부에서 곧장 값을 찾는 경우 **리프까지 가지 않을** 수 있음.
  - 범용적 개념으로 교과서/표준 알고리즘 설명에 자주 등장.
- **단점**
  - 내부에 값이 섞여 **팬아웃이 상대적으로 작아질** 수 있음.
  - **리프 연결 부재**로 **범위 질의**가 B+ 대비 비효율적.

### B+tree
- **장점**
  - **팬아웃↑ → 높이↓ → I/O↓** (대규모 데이터에서 체감 큼).
  - **리프 연결** 덕분에 **범위/정렬 질의**가 매우 빠름.
  - 실무(데이터베이스/파일시스템)에서 **사실상 표준**.
- **단점**
  - 값이 리프에만 있으므로 **항상 리프까지 내려감**.
  - 삽입/삭제 시 **분할/병합 빈도**가 높으면 쓰기 I/O 증가(→ DB는 **WAL** 등으로 완화).

---

## 알고리즘 예시

### 1) B+tree 탐색(점 조회)
1. 루트에서 시작, **키 비교**로 자식을 선택하며 **리프까지** 내려감.
2. 리프에서 **키를 이진 탐색**하여 값을 반환. (없으면 실패)

### 2) B+tree 삽입(요약)
1. 탐색 경로로 **리프** 도달 → 위치에 삽입.
2. 리프가 **초과(overflow)**면 **split**: 절반씩 나누고 **분할 키**를 **부모**에 올림.
3. 부모도 초과면 **연쇄 split**(최대 루트 split → **높이+1**).

### 3) B+tree 삭제(요약)
1. 리프에서 키 삭제.
2. 노드가 **최소 점유율** 미만이면 **형제와 재분배** 또는 **병합(merge)**, 부모 키 갱신.
3. 루트가 비면 **높이-1**.

### 4) 작은 삽입 예 (차수 M=4, 간단화)
- 초기: 빈 트리 → `10, 20, 30, 40` 삽입 중 리프가 가득 차면  
  리프 `[10,20,30,40]` → split → `[10,20] | [30,40]`, 부모에 **분할 키 30** 승격.  
- 이후 `50` 삽입 시 오른쪽 리프 → `[30,40,50]` (아직 여유).

> 핵심: **split 시 절반 분배 + 부모에 분할 키 승격**.

---

## 자주묻는 면접 질문

1. **B-tree vs B+tree 핵심 차이?**  
   → **값 위치**(B: 내부/리프 가능, **B+는 리프 전용**), **리프 연결**(B+: 있음), **팬아웃/높이**(B+가 유리).

2. **왜 BST 대신 B/B+를 쓰나?**  
   → 디스크는 랜덤 I/O가 비싸다. **다진 구조**로 **높이를 낮춰** I/O를 줄이기 위해.

3. **B+가 범위 질의에 강한 이유?**  
   → 첫 리프만 찾고 **리프 연결**로 **연속 스캔**하기 때문.

4. **삽입/삭제 시 균형 유지 방법?**  
   → **split/재분배/merge**로 최소·최대 점유율을 유지, **모든 리프 동일 높이**.

5. **클러스터드 vs 보조 인덱스(실무)**  
   → 클러스터드: 리프가 **실제 행**(또는 PK 순 저장). 보조: 리프에 **(인덱스 키+PK)** → 행 필요 시 **추가 조회**.

6. **해시 인덱스 vs B+트리 선택 기준?**  
   → 해시: **정확한 점 조회**에 최적(범위×). B+: **범위/정렬** 포함 일반 질의에 적합.

---

