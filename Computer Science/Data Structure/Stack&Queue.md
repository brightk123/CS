# 스택(Stack) & 큐(Queue)

---

## 1. 스택 (Stack)

> 한 쪽 끝에서만 데이터를 넣고 뺄 수 있는 선형 자료구조. **LIFO (Last-In, First-Out)** 구조로, 마지막에 삽입된 데이터가 가장 먼저 제거됨.

### **기본 연산 (Operations)**

- **`Push`**: 스택의 맨 위에 데이터 추가
- **`Pop`**: 스택 맨 위의 데이터 제거 및 반환
- **`Peek`**: 스택 맨 위의 데이터 확인 (제거하지 않음)
- **`isEmpty`**: 스택이 비어있는지 확인
- **`isFull`**: 스택이 가득 차있는지 확인
- **`Search`**: 스택에 특정 데이터가 존재하는지 확인 (맨 위에서부터의 순서 반환)

### **동작 원리 (배열 기반)**

1.  포인터 `top`을 이용해 스택의 맨 위를 가리킴.
2.  스택 생성 직후, `top`의 값에 `-1`을 할당하여 스택이 비어있음을 나타냄.
3.  **Push**:
    - `isFull`을 먼저 확인.
    - `top`의 값을 1 증가시킨 후, 해당 위치에 데이터를 삽입.
4.  **Pop**:
    - `isEmpty`를 먼저 확인.
    - 현재 `top`이 가리키는 데이터를 반환한 후, `top`의 값을 1 감소시킴.

### **Java에서의 사용**

- `import java.util.Stack;`을 통해 스택 클래스를 사용할 수 있음.

```java
import java.util.Stack;

Stack<Integer> stack = new Stack<>();
```

## 추가: Java Stack 클래스 사용 권장 사항

Java의 `Stack` 클래스는 오래된 `Vector`를 상속받아 성능상 약점이 있어 현재는 사용을 **지양**합니다. `Vector`는 모든 메소드가 동기화(synchronized) 처리되어 있어 단일 스레드 환경에서는 불필요한 오버헤드를 유발합니다.

대신 **`Deque` 인터페이스**와 그 구현체인 `ArrayDeque`를 사용하는 것을 권장합니다. `Deque`는 양방향 자료구조지만, 한쪽으로만 사용하면 스택처럼 동작시킬 수 있어 더 유연하고 성능이 좋습니다.

---

## 큐 (Queue)

> 양쪽 끝에서 데이터의 삽입과 삭제가 각각 이루어지는 선형 자료구조. **FIFO (First-In, First-Out)** 구조로, 먼저 삽입된 데이터가 먼저 제거됩니다.

### **큐의 기본 연산**

-   **`enQueue`**: 큐의 맨 뒤(rear)에 데이터를 삽입합니다.
-   **`deQueue`**: 큐의 맨 앞(front)의 데이터를 제거하고 반환합니다.
-   **`isEmpty`**: 큐가 비어있는지 확인합니다.
-   **`isFull`**: 큐가 가득 찼는지 확인합니다.

---

### **동작 원리 1: 선형 큐**

#### **포인터 및 초기 상태**

-   포인터 `front`를 활용해 큐의 맨 앞을, `rear`로 큐의 맨 뒤를 가리킵니다. (초기값: -1)

#### **데이터 삽입 (Enqueue)**

1.  `isFull`인지 확인합니다.
2.  `rear` 인덱스에 데이터를 넣고 `rear`를 1 증가시킵니다.

#### **데이터 삭제 (Dequeue)**

1.  `isEmpty`인지 확인합니다.
2.  `front`를 1 증가시킨 후, 이전 `front` 위치의 데이터를 반환하고 해당 위치는 `null`로 채웁니다.

#### **상태 확인 및 단점**

-   **비어있는 상태**: `front == rear`
-   **가득 찬 상태**: `rear == (큐의 사이즈 - 1)`
-   **단점**: 큐의 앞부분에 빈 메모리가 남아있어도 `rear`가 배열의 끝에 도달하면 가득 찬 것으로 판단하여 공간을 재활용할 수 없습니다.

---

### **동작 원리 2: 원형 큐 (Circular Queue)**

> 선형 큐의 단점을 개선한 버전으로, 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주합니다.



#### **포인터 및 초기 상태**

-   `front`는 첫 번째 요소의 인덱스를, `rear`는 마지막 요소의 인덱스를 가리킵니다.
-   초기값은 `front`와 `rear` 모두 `0`이며, 큐가 비어있는 상태를 의미합니다. (구현에 따라 -1로 초기화하기도 합니다.)

#### **데이터 삽입 (Enqueue)**

1.  `isFull`인지 확인합니다.
2.  `rear`를 다음 위치로 원형으로 이동시킨 후 (`rear = (rear + 1) % 큐 사이즈`), 데이터 값을 할당합니다.

#### **데이터 삭제 (Dequeue)**

1.  `isEmpty`인지 확인합니다.
2.  `front` 위치의 데이터를 반환한 후, `front`를 다음 위치로 원형으로 이동시킵니다 (`front = (front + 1) % 큐 사이즈`).

#### **상태 확인**

-   **비어있는 상태**: `front == rear`
-   **가득 찬 상태**: `(rear + 1) % (큐의 사이즈) == front` (큐를 가득 채우지 않고 한 칸을 비워두어 포화 상태와 공백 상태를 구분합니다.)

---

### **큐의 활용**

-   **너비 우선 탐색 (BFS)**
    시작 노드를 큐에 넣고, 큐에서 노드를 꺼내 탐색한 뒤 해당 노드와 인접한 노드들을 모두 큐에 삽입하는 과정을 반복합니다. 가까운 관계부터 순서대로 탐색하는 데 효과적입니다.

-   **운영체제(OS) 작업 스케줄링**
    여러 프로세스를 공정하게 처리하기 위해 큐를 사용합니다. CPU를 사용하기 위해 대기하는 프로세스들을 큐에 저장하고, 들어온 순서대로 CPU 자원을 할당합니다.

-   **버퍼(Buffer)**
    데이터를 한 곳에서 다른 곳으로 전송할 때 발생하는 속도 차이 문제를 해결하기 위해 사용됩니다. 예를 들어, 동영상 스트리밍 시 데이터를 미리 큐에 받아놓고(버퍼링) 순서대로 재생하여, 네트워크 속도가 일시적으로 느려져도 영상이 끊기지 않게 합니다.