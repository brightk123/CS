# 트랜잭션(TCL)

# 개념

DB의 상태를 변화시키기 해서 수행하는 작업의 단위

- 아래의 질의어(SQL)를 이용하여 데이터베이스를 접근 하는 것을 의미
  - SELECT
  - INSERT
  - DELETE
  - UPDATE

→ 예시

```
A 회원이 커피 주문 앱으로 커피를 주문하려고 합니다. 아이스 아메리카노 1잔을 선택했고, 결제 버튼을 눌렀습니다. 결제가 성공하고, 데이터베이스에 회원의 주문 내역이 정상적으로 등록되었습니다.
```

# 특징

트랜잭션의 특징은 크게 4가지로 구분된다. -ACID

- 원자성 (Atomicity)
- 일관성 (Consistency)
- 독립성 (Isolation)
- 지속성 (Durability)

| 원자성 (Atomicity)   | **트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것**이다. |
| -------------------- | ----------------------------------------------------------------------------------------- |
| 일관성 (Consistency) | **트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것**이다.                       |
| 독립성 (Isolation)   | 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점을 가리킨다.        |
| 지속성 (Durability)  | 지속성은 트랜잭션이 성공적으로 완료됬을 경우**, 결과는 영구적으로 반영되어야 한다는 점**  |
|                      |                                                                                           |

# COMMIT과 ROLLBACK

## COMMIT

: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성 있는 상태일 때 이를 알려주기 위해 사용하는 연산

## ROLLBACK

: 하나의 트랜잭션 처리가 비정상적으로 종료도어 트랜잭션 원자성이 깨진 경우

- 참고
  - **가시성**: 커밋 전 변경은 **내 세션(같은 트랜잭션)** 에만 보입니다. 다른 세션은 **이전 스냅샷**을 봅니다(MVCC).
    - 예외: 격리수준이 **READ UNCOMMITTED**면 남의 미커밋 변경(더러운 읽기)을 볼 수 있지만, 실무에선 거의 쓰지 않습니다.
  - **지속성**: 커밋 전 상태는 **확정 아님** → **ROLLBACK**하면 전부 사라집니다. 장애가 나도 **커밋되지 않은 변경은 복구 대상이 아님**(확정 로그에 고정되지 않았으니까).

# 문법

```sql
-- 공통 (MySQL: START TRANSACTION; 도 가능)
BEGIN;

UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
UPDATE accounts SET balance = balance + 1000 WHERE id = 2;

-- 모두 정상
COMMIT;

-- (문제 생기면 대신)
-- ROLLBACK;

```

---

# DBMS의 전략 → 딥한 내용이라 면접용으로만 정리해둘게용

### 1. DBMS의 구성

- **Query Processor (질의 처리기)**
  : SQL을 **이해하고 최적 실행계획으로 바꾼 뒤 실행**시키는 층
- **Storage System (저장 시스템)**
  : 데이터를 **페이지(page) 단위**로 메모리↔디스크에 안전/빠르게 저장·복구
  - **Buffer Manager**: 디스크 페이지를 **메인메모리(버퍼풀)**에 캐싱, 교체 정책 관리
  - **Transaction Manager**: **BEGIN/COMMIT/ROLLBACK**, 트랜잭션 ID/격리 수준 관리
- 왜 두 층으로 나누나?
  - **질의 처리기**는 “**어떻게 빨리 계산할까**”에 집중(계획/연산)
  - **저장 시스템**은 “**어떻게 안전·빠르게 저장/복구할까**”에 집중(I/O/복구/동시성)

---

### 1) DBMS 큰 그림

- **Query Processor**: SQL 파싱 → 최적 실행계획 → 실행.
- **Storage System**: 페이지 단위 I/O, 버퍼/트랜잭션/복구/인덱스 관리.
- **I/O 단위**: 고정 길이 **page**(예: 8KB).
- **저장**: 기본은 **디스크**, 일부는 **메모리(버퍼 풀)**에 캐싱.

### 2) Buffer Manager 한 줄 정의

- 디스크 페이지를 메모리에 **캐싱/교체/플러시**하는 모듈.

### 3) UNDO / REDO 한 줄 정의

- **UNDO**: 미커밋 변경을 **되돌림**(롤백/크래시 시).
- **REDO**: 커밋됐지만 디스크에 미반영된 변경을 **재적용**(크래시 후).

### **4) 두 축의 정책 (암기 포인트)**

**(A) 커밋 전 더티 페이지를 디스크에 내릴 수 있나?**

- **steal**: 가능 → **UNDO 필요**(미커밋이 디스크에 있을 수 있음)
- **no-steal(¬steal)**: 불가 → **UNDO 불필요**(미커밋은 디스크에 없음)

**(B) 커밋 시 수정 페이지를 반드시 디스크에 쓰나?**

- **FORCE**: 예 → **REDO 불필요**(커밋 시 이미 반영됨)
- **no-FORCE(¬FORCE)**: 아니오 → **REDO 필요**(나중에 쓰므로)

### 5) 2×2 요약 표 (무조건 외우기)

|              | FORCE             | ¬FORCE            |
| ------------ | ----------------- | ----------------- |
| **no-steal** | UNDO× / REDO×     | UNDO× / **REDO○** |
| **steal**    | **UNDO○** / REDO× | **UNDO○ / REDO○** |

> 현실 대부분 DBMS = steal + FORCE + WAL
>
> ⇒ **UNDO + REDO 모두 필요** (WAL: 로그를 먼저 디스크에 쓰고, 데이터는 나중에 써서 안전·성능 확보)
