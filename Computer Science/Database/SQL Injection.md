## 🎯 SQL Injection이란?

SQL Injection은 해커가 웹사이트의 입력 창(예: 아이디, 비밀번호 입력란)에 일반적인 데이터가 아닌,
데이터베이스가 알아들을 수 있는 **비정상적인 명령(SQL 쿼리문)** 을 섞어 넣어서 데이터베이스를 조작하는 공격 기술

쉽게 말해, 레스토랑에서 햄버거를 주문해야 하는데, 주문서에 햄버거 이름 대신 "옆 테이블 손님 음식 훔쳐 와"라는 비밀 메모를 적는 것과 비슷

### 📜 참고 내용 요약

| 개념 | 내용 | 쉬운 비유 |
| :--- | :--- | :--- |
| **SQL Injection** | 조작된 SQL 쿼리문이 DB에 전달되어 비정상적 명령을 실행하는 공격 | 비밀 주문서에 적힌 **숨겨진 나쁜 명령** |
| **인증 우회** | 로그인 시 비밀번호 입력란에 다른 쿼리문(`$\text{; DELETE}$` 등)을 넣어 인증을 통과하거나 DB 내용을 삭제함 | 비밀번호 대신 **'문 열어 + 물건 버려'** 명령을 넣는 것 |
| **데이터 노출** | 시스템 에러 메시지를 역이용하여 DB 구조를 알아내 해킹에 활용함 | 오류 메시지를 보고 **보물 창고의 설계도**를 유추하는 것 |

-----

## 🔪 공격 방법 예시 (쉽게 이해하기)

### 1. 인증 우회 및 파괴 (로그인 문 부수기)

로그인할 때 아이디와 비밀번호가 맞는지 확인하는 기본적인 명령은 다음과 같음
```
$$
\text{SELECT * FROM USER WHERE ID = "abc" AND PASSWORD = "1234";}
```
`$$`이 명령은 "아이디가 'abc'이고 비밀번호가 '1234'인 사용자가 있는지 찾아봐"라는 뜻

**🚨 공격자가 이렇게 입력하면?**

공격자가 비밀번호 입력 창에 `$\mathbf{1234; \text{DELETE * USER FROM ID = "1";}}$` 대신, 훨씬 간단한 우회 구문을 넣을 수도 있음

예를 들어, 비밀번호 입력란에 다음과 같이 입력 : `$\mathbf{\text{' OR '1'='1}}$`

* 원래 실행되려던 명령이 (예시):
$$

```
$$\\text{SELECT \* FROM USER WHERE ID = "abc" AND PASSWORD = "1234";}
$$
$$
```

  * **공격 후 실행될 수 있는 명령:** (만약 서버가 입력 내용을 그대로 넣는다면)
    $$
    ```
    $$$$\\text{SELECT \* FROM USER WHERE ID = "abc" AND PASSWORD = '\\text{' OR '1'='1';}
    $$
    $$$$
    ```
    $$명령어 안의 `$\mathbf{\text{'1'='1'}}$`은 무조건 **참(True)** 인 문장
    '비밀번호가 `$\text{'\text{'}$`이거나 `$\text{'1'='1'}$`이다' 라는 뜻
    `$\mathbf{\text{'1'='1'}}$` 덕분에 비밀번호가 맞든 틀리든 무조건 **참(True)** 이 되어버려서 **로그인이 성공**하는 치명적인 상황이 발생

### 2. 데이터 노출

보통 웹사이트에 에러가 나면, 개발자는 그 에러 메시지를 보고 어디가 문제인지 파악

  * **해커의 수법:** 해커는 일부러 웹 주소(URL)에 이상한 값을 넣어 **에러를 강제로 발생**시킴
  * **목표:** 이때 서버가 "쿼리 명령이 잘못되어서 `$\text{USER}$` 테이블에서 에러가 났습니다."와 같이 **너무 자세한 오류 메시지**를 보여주면, 해커는 그 메시지를 읽고 이 웹사이트의 **데이터베이스 구조(테이블 이름, 컬럼 이름)** 를 알아낼 수 있음
  * **결과:** 마치 보물 창고 문은 안 열리는데, **실수로 문에 적힌 설계도**를 읽어서 창고 안의 구조를 파악하는 것과 같음. 이를 통해 다음 공격을 준비

-----

## 🛡️ 방어 방법

### 1. 🙅‍♀️ 특수문자 검사

로그인 입력값에 **SQL 명령어로 사용될 수 있는 특수문자** (예: `$\mathbf{\text{'}}$`, `$\mathbf{\text{;}}$`, `$\mathbf{\text{--}}$`, `$\mathbf{\text{<}}$`, `$\mathbf{\text{>}}$` 등)가 들어오면, 아예 요청을 막거나 해당 문자들을 제거

### 2. 🤫 에러 메시지 감추기

데이터베이스에서 에러가 발생하더라도, 사용자에게는 "**죄송합니다. 오류가 발생했습니다.**"처럼 **간단하고 추상적인 메시지**만 보여주고, **자세한 기술 정보**는 보여주지 않도록 숨김

### 3. ✨ `$\text{Prepared Statement}$` 사용

가장 **효과적인** 방어 방법

  * `$\text{Prepared Statement}$`는 데이터베이스에 명령을 보낼 때, **명령의 구조**와 **입력할 데이터**를 **분리**해서 전달

  * 입력 데이터에 특수문자($\text{'}$ 등)가 있더라도, 데이터베이스는 그것을 **명령어의 일부**로 보지 않고, **단순한 텍스트 값**으로만 인식하도록 **자동으로 변환(escaping)** 해줌

  * **원래:** "비밀번호는 `$\text{1234; DELETE}$`"

  * **`$\text{Prepared Statement}$` 후:** "비밀번호는 **'1234; DELETE'**"

      * `$\text{DELETE}$`가 더 이상 실행 가능한 명령이 아니라, 그냥 **비밀번호에 포함된 이상한 문자**로 취급

-----

## 🗣️ 면접 예상 질문 및 답변

### 1. `$\text{SQL Injection}$`이란?

**답변:** `$\text{SQL Injection}$`은 웹 애플리케이션의 입력 창을 통해 해커가 **조작된 `$\text{SQL}$` 쿼리문**을 데이터베이스에 삽입하여, `$\text{DB}$`의 데이터를 유출하거나 조작하는 보안 취약점 공격 기법

### 2. `$\text{SQL Injection}$`을 방어하는 가장 효과적인 방법은?

**답변:** 가장 효과적인 방법은 **`$\text{Prepared Statement}$`** (또는 바인딩 변수)를 사용하는 것

이는 `$\text{SQL}$` 명령과 사용자의 입력 값을 분리하여 처리함으로써, 사용자의 입력이 `$\text{DB}$` 명령어로 해석되는 것을 원천적으로 차단

### 3. `$\text{Prepared Statement}$`를 사용해야 하는 이유는?

**답변:** `$\text{Prepared Statement}$`는 입력값에 포함된 `$\text{'}$` (작은따옴표)와 같은 **특수문자를 자동으로 `$\text{escaping}$`**하여, 데이터가 `$\text{SQL}$` 명령의 일부가 아닌 단순한 문자열 값으로 처리되게 보장

이는 개발자가 일일이 특수문자를 검사하는 것보다 훨씬 안전하고 확실한 방법

### 4. 방어 방법 중 `$\text{Input}$` 값 검사의 한계는?

**답변:** `$\text{Input}$` 값 검사(`$\text{Filtering}$`)는 일부 특수문자를 막을 수 있지만, **우회 기법**(`$\text{Encoding}$` 등)이 존재하기 때문에 완벽한 방어가 어려움

또한, 모든 공격 패턴을 미리 예측하여 막는 것은 현실적으로 불가능

따라서 **`$\text{Prepared Statement}$`** 와 같은 **근본적인 방어 메커니즘**을 병행하는 것이 필수적
