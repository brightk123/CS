# HTTP & HTTPS

> 개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용하면 된다.
> 

# HTTP(Hyper Text Transfer Protocol)

> 포트번호 : 80
> 

인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

→ 텍스트 교환이라 누군가가 신호를 가로채면 내용이 노출되는 보안 이슈가 발생한다.

이때 `HTTPS` 가 이 문제를 해결할 수 있다!!

### ⇒ 아무런 보안 장치가 없다!

- 보안 취약성 : 제3자가 데이터를 엿볼 수 있다
- 무결성 문제 : 데이터가 전송 중에 변경되거나 조작될 수 있다
- 신원 보증의 문제

# HTTPS(Hyper Text Transfer Protocol Secure)

> 포트번호 443
> 

<aside>
💡

HTTP + 보안 장치(데이터 암호화)

</aside>

### ⇒ 보안 극복!

- 보안 취약성 해결 : SSL/TLS 프로토콜 사용 ( 데이터 암호화)
    - 대칭키로 호화 진행
- 신뢰할 수 있는 CA 기업을 선택해, 공개키 관리를 부탁한다.

> CA(Certificate Authority) : 공개키를 저장해주는 신뢰성이 검증된ㅠ

출처 : [https://minix.tistory.com/397](https://minix.tistory.com/397)

1. site → CA : 인증서 발급 요청(CSR 전송)
2. CA : 도메인 소유/신원 검증 후, “사이트 정보 + 사이트 공개키”에 대해 CA 개인키로 “서명”해서 인증서 생성
    
    “암호화”가 아니라 “서명”이 맞습니다.
    
3. CA → site : 서버 인증서(및 중간 인증서 체인) 발급
4. 브라우저는 (미리 내장된) 신뢰 루트 CA 공개키들을 가지고 있음
    
    “CA가 브라우저에 제공”이라기보다, OS/브라우저에 루트 인증서가 사전 탑재돼 있습니다.
    
5. 브라우저 → site : HTTPS 접속 요청(ClientHello)
6. site → 브라우저 : 서버 인증서(체인) 전달
7. 브라우저 : CA 공개키(체인)로 인증서 서명 검증 + 도메인/유효기간/폐지 여부 확인
8. 브라우저 : 인증서에서 “사이트 공개키”와 “사이트 도메인 정보”를 얻음
9. (현대 표준) 브라우저와 사이트는 ECDHE 같은 “키 교환”으로 공유 비밀을 함께 계산
    
    즉, “사이트 공개키로 대칭키를 암호화해 전송”을 보통 하지 않습니다. (구식 RSA 키교환 방식에 가까움)
    
10. 공유 비밀에서 세션 대칭키(암호화/무결성 키)를 파생하고, 서로 Finished 메시지로 핸드셰이크 무결성 확인
11. 이후 데이터는 그 “세션 대칭키”로 안전하게 암호화해 주고받음(HTTPS)
